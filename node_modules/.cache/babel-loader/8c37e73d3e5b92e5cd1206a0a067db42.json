{"ast":null,"code":"// (c) 2018, Mariusz Nowak\n// SPDX-License-Identifier: ISC\n// Derived from https://github.com/medikoo/lru-queue\nexport function lruQueue(limit) {\n  var size = 0;\n  var base = 1;\n  var queue = Object.create(null);\n  var map = Object.create(null);\n  var index = 0;\n\n  var del = function del(id) {\n    var oldIndex = map[id];\n    if (!oldIndex) return;\n    delete queue[oldIndex];\n    delete map[id];\n    --size;\n    if (base !== oldIndex) return;\n\n    if (!size) {\n      index = 0;\n      base = 1;\n      return;\n    }\n\n    while (!hasOwnProperty.call(queue, ++base)) {\n      continue;\n    }\n  };\n\n  limit = Math.abs(limit);\n  return {\n    hit: function hit(id) {\n      var oldIndex = map[id];\n      var nuIndex = ++index;\n      queue[nuIndex] = id;\n      map[id] = nuIndex;\n\n      if (!oldIndex) {\n        ++size;\n        if (size <= limit) return undefined;\n        id = queue[base];\n        del(id);\n        return id;\n      }\n\n      delete queue[oldIndex];\n      if (base !== oldIndex) return undefined;\n\n      while (!hasOwnProperty.call(queue, ++base)) {\n        continue;\n      }\n\n      return undefined;\n    },\n    delete: del,\n    clear: function clear() {\n      size = index = 0;\n      base = 1;\n      queue = Object.create(null);\n      map = Object.create(null);\n    }\n  };\n}\n;","map":{"version":3,"sources":["/Users/elimunn/Desktop/plot-recipes/node_modules/mathjs/lib/esm/utils/lruQueue.js"],"names":["lruQueue","limit","size","base","queue","Object","create","map","index","del","id","oldIndex","hasOwnProperty","call","Math","abs","hit","nuIndex","undefined","delete","clear"],"mappings":"AAAA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyB;AAC9B,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;AACA,MAAIC,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAV;AACA,MAAIE,KAAK,GAAG,CAAZ;;AAEA,MAAIC,GAAG,GAAG,SAASA,GAAT,CAAaC,EAAb,EAAiB;AACzB,QAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,QAAI,CAACC,QAAL,EAAe;AACf,WAAOP,KAAK,CAACO,QAAD,CAAZ;AACA,WAAOJ,GAAG,CAACG,EAAD,CAAV;AACA,MAAER,IAAF;AACA,QAAIC,IAAI,KAAKQ,QAAb,EAAuB;;AAEvB,QAAI,CAACT,IAAL,EAAW;AACTM,MAAAA,KAAK,GAAG,CAAR;AACAL,MAAAA,IAAI,GAAG,CAAP;AACA;AACD;;AAED,WAAO,CAACS,cAAc,CAACC,IAAf,CAAoBT,KAApB,EAA2B,EAAED,IAA7B,CAAR,EAA4C;AAC1C;AACD;AACF,GAjBD;;AAmBAF,EAAAA,KAAK,GAAGa,IAAI,CAACC,GAAL,CAASd,KAAT,CAAR;AACA,SAAO;AACLe,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAaN,EAAb,EAAiB;AACpB,UAAIC,QAAQ,GAAGJ,GAAG,CAACG,EAAD,CAAlB;AACA,UAAIO,OAAO,GAAG,EAAET,KAAhB;AACAJ,MAAAA,KAAK,CAACa,OAAD,CAAL,GAAiBP,EAAjB;AACAH,MAAAA,GAAG,CAACG,EAAD,CAAH,GAAUO,OAAV;;AAEA,UAAI,CAACN,QAAL,EAAe;AACb,UAAET,IAAF;AACA,YAAIA,IAAI,IAAID,KAAZ,EAAmB,OAAOiB,SAAP;AACnBR,QAAAA,EAAE,GAAGN,KAAK,CAACD,IAAD,CAAV;AACAM,QAAAA,GAAG,CAACC,EAAD,CAAH;AACA,eAAOA,EAAP;AACD;;AAED,aAAON,KAAK,CAACO,QAAD,CAAZ;AACA,UAAIR,IAAI,KAAKQ,QAAb,EAAuB,OAAOO,SAAP;;AAEvB,aAAO,CAACN,cAAc,CAACC,IAAf,CAAoBT,KAApB,EAA2B,EAAED,IAA7B,CAAR,EAA4C;AAC1C;AACD;;AAED,aAAOe,SAAP;AACD,KAvBI;AAwBLC,IAAAA,MAAM,EAAEV,GAxBH;AAyBLW,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtBlB,MAAAA,IAAI,GAAGM,KAAK,GAAG,CAAf;AACAL,MAAAA,IAAI,GAAG,CAAP;AACAC,MAAAA,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAR;AACAC,MAAAA,GAAG,GAAGF,MAAM,CAACC,MAAP,CAAc,IAAd,CAAN;AACD;AA9BI,GAAP;AAgCD;AACD","sourcesContent":["// (c) 2018, Mariusz Nowak\n// SPDX-License-Identifier: ISC\n// Derived from https://github.com/medikoo/lru-queue\nexport function lruQueue(limit) {\n  var size = 0;\n  var base = 1;\n  var queue = Object.create(null);\n  var map = Object.create(null);\n  var index = 0;\n\n  var del = function del(id) {\n    var oldIndex = map[id];\n    if (!oldIndex) return;\n    delete queue[oldIndex];\n    delete map[id];\n    --size;\n    if (base !== oldIndex) return;\n\n    if (!size) {\n      index = 0;\n      base = 1;\n      return;\n    }\n\n    while (!hasOwnProperty.call(queue, ++base)) {\n      continue;\n    }\n  };\n\n  limit = Math.abs(limit);\n  return {\n    hit: function hit(id) {\n      var oldIndex = map[id];\n      var nuIndex = ++index;\n      queue[nuIndex] = id;\n      map[id] = nuIndex;\n\n      if (!oldIndex) {\n        ++size;\n        if (size <= limit) return undefined;\n        id = queue[base];\n        del(id);\n        return id;\n      }\n\n      delete queue[oldIndex];\n      if (base !== oldIndex) return undefined;\n\n      while (!hasOwnProperty.call(queue, ++base)) {\n        continue;\n      }\n\n      return undefined;\n    },\n    delete: del,\n    clear: function clear() {\n      size = index = 0;\n      base = 1;\n      queue = Object.create(null);\n      map = Object.create(null);\n    }\n  };\n}\n;"]},"metadata":{},"sourceType":"module"}