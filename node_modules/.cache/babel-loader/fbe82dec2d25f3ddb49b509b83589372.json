{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        } // check for word size suffix\n\n\n        var sign = currentCharacter(state);\n\n        if (sign === 'i') {\n          state.token += sign;\n          next(state);\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  return parse;\n});","map":{"version":3,"sources":["/Users/elimunn/Desktop/plot-recipes/node_modules/mathjs/lib/esm/expression/parse.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","factory","isAccessorNode","isConstantNode","isFunctionNode","isOperatorNode","isSymbolNode","deepMap","name","dependencies","createParse","_ref","typed","numeric","config","AccessorNode","ArrayNode","AssignmentNode","BlockNode","ConditionalNode","ConstantNode","FunctionAssignmentNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","RangeNode","RelationalNode","SymbolNode","parse","string","expression","parseStart","ArrayMatrix","expressions","parseMultiple","stringObject","options","extraNodes","nodes","undefined","elem","TypeError","TOKENTYPE","NULL","DELIMITER","NUMBER","SYMBOL","UNKNOWN","DELIMITERS","NAMED_DELIMITERS","mod","to","in","and","xor","or","not","CONSTANTS","true","false","null","NUMERIC_CONSTANTS","initialState","comment","index","token","tokenType","nestingLevel","conditionalLevel","currentString","state","substr","currentCharacter","next","prevCharacter","charAt","nextCharacter","getToken","isWhitespace","c1","c2","c3","isDigitDot","_c","isHexDigit","sign","isDigit","isDecimalMark","createSyntaxError","isAlpha","getTokenSkipNewline","openParams","closeParams","c","cPrev","cNext","isValidLatinOrGreek","isValidMathSymbol","test","high","low","node","parseBlock","createError","blocks","visible","parseAssignment","push","args","value","valid","parseConditional","object","fn","forEach","arg","parseLogicalOr","prev","condition","trueExpr","falseExpr","parseLogicalXor","parseLogicalAnd","parseBitwiseOr","parseBitwiseXor","parseBitwiseAnd","parseRelational","params","parseShift","conditionals","operators","cond","map","parseConversion","parseRange","parseAddSubtract","parseMultiplyDivide","last","parseImplicitMultiplication","parseRule2","op","parseUnary","tokenStates","pop","parsePow","parseLeftHandOperators","parseCustomNodes","parseAccessors","CustomNode","parseSymbol","indexOf","parseDoubleQuotesString","types","dotNotation","str","parseDoubleQuotesStringToken","parseSingleQuotesString","JSON","parseSingleQuotesStringToken","parseMatrix","array","rows","cols","row","parseRow","items","r","parseObject","len","properties","parseNumber","numberStr","number","parseParentheses","parseEnd","col","message","error","SyntaxError","char"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { factory } from '../utils/factory.js';\nimport { isAccessorNode, isConstantNode, isFunctionNode, isOperatorNode, isSymbolNode } from '../utils/is.js';\nimport { deepMap } from '../utils/collection.js';\nimport { hasOwnProperty } from '../utils/object.js';\nvar name = 'parse';\nvar dependencies = ['typed', 'numeric', 'config', 'AccessorNode', 'ArrayNode', 'AssignmentNode', 'BlockNode', 'ConditionalNode', 'ConstantNode', 'FunctionAssignmentNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'RangeNode', 'RelationalNode', 'SymbolNode'];\nexport var createParse = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    typed,\n    numeric,\n    config,\n    AccessorNode,\n    ArrayNode,\n    AssignmentNode,\n    BlockNode,\n    ConditionalNode,\n    ConstantNode,\n    FunctionAssignmentNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    RangeNode,\n    RelationalNode,\n    SymbolNode\n  } = _ref;\n\n  /**\n   * Parse an expression. Returns a node tree, which can be evaluated by\n   * invoking node.evaluate().\n   *\n   * Note the evaluating arbitrary expressions may involve security risks,\n   * see [https://mathjs.org/docs/expressions/security.html](https://mathjs.org/docs/expressions/security.html) for more information.\n   *\n   * Syntax:\n   *\n   *     math.parse(expr)\n   *     math.parse(expr, options)\n   *     math.parse([expr1, expr2, expr3, ...])\n   *     math.parse([expr1, expr2, expr3, ...], options)\n   *\n   * Example:\n   *\n   *     const node1 = math.parse('sqrt(3^2 + 4^2)')\n   *     node1.compile().evaluate() // 5\n   *\n   *     let scope = {a:3, b:4}\n   *     const node2 = math.parse('a * b') // 12\n   *     const code2 = node2.compile()\n   *     code2.evaluate(scope) // 12\n   *     scope.a = 5\n   *     code2.evaluate(scope) // 20\n   *\n   *     const nodes = math.parse(['a = 3', 'b = 4', 'a * b'])\n   *     nodes[2].compile().evaluate() // 12\n   *\n   * See also:\n   *\n   *     evaluate, compile\n   *\n   * @param {string | string[] | Matrix} expr          Expression to be parsed\n   * @param {{nodes: Object<string, Node>}} [options]  Available options:\n   *                                                   - `nodes` a set of custom nodes\n   * @return {Node | Node[]} node\n   * @throws {Error}\n   */\n  var parse = typed(name, {\n    string: function string(expression) {\n      return parseStart(expression, {});\n    },\n    'Array | Matrix': function ArrayMatrix(expressions) {\n      return parseMultiple(expressions, {});\n    },\n    'string, Object': function stringObject(expression, options) {\n      var extraNodes = options.nodes !== undefined ? options.nodes : {};\n      return parseStart(expression, extraNodes);\n    },\n    'Array | Matrix, Object': parseMultiple\n  });\n\n  function parseMultiple(expressions) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var extraNodes = options.nodes !== undefined ? options.nodes : {}; // parse an array or matrix with expressions\n\n    return deepMap(expressions, function (elem) {\n      if (typeof elem !== 'string') throw new TypeError('String expected');\n      return parseStart(elem, extraNodes);\n    });\n  } // token types enumeration\n\n\n  var TOKENTYPE = {\n    NULL: 0,\n    DELIMITER: 1,\n    NUMBER: 2,\n    SYMBOL: 3,\n    UNKNOWN: 4\n  }; // map with all delimiters\n\n  var DELIMITERS = {\n    ',': true,\n    '(': true,\n    ')': true,\n    '[': true,\n    ']': true,\n    '{': true,\n    '}': true,\n    '\"': true,\n    '\\'': true,\n    ';': true,\n    '+': true,\n    '-': true,\n    '*': true,\n    '.*': true,\n    '/': true,\n    './': true,\n    '%': true,\n    '^': true,\n    '.^': true,\n    '~': true,\n    '!': true,\n    '&': true,\n    '|': true,\n    '^|': true,\n    '=': true,\n    ':': true,\n    '?': true,\n    '==': true,\n    '!=': true,\n    '<': true,\n    '>': true,\n    '<=': true,\n    '>=': true,\n    '<<': true,\n    '>>': true,\n    '>>>': true\n  }; // map with all named delimiters\n\n  var NAMED_DELIMITERS = {\n    mod: true,\n    to: true,\n    in: true,\n    and: true,\n    xor: true,\n    or: true,\n    not: true\n  };\n  var CONSTANTS = {\n    true: true,\n    false: false,\n    null: null,\n    undefined: undefined\n  };\n  var NUMERIC_CONSTANTS = ['NaN', 'Infinity'];\n\n  function initialState() {\n    return {\n      extraNodes: {},\n      // current extra nodes, must be careful not to mutate\n      expression: '',\n      // current expression\n      comment: '',\n      // last parsed comment\n      index: 0,\n      // current index in expr\n      token: '',\n      // current token\n      tokenType: TOKENTYPE.NULL,\n      // type of the token\n      nestingLevel: 0,\n      // level of nesting inside parameters, used to ignore newline characters\n      conditionalLevel: null // when a conditional is being parsed, the level of the conditional is stored here\n\n    };\n  }\n  /**\n   * View upto `length` characters of the expression starting at the current character.\n   *\n   * @param {Object} state\n   * @param {number} [length=1] Number of characters to view\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentString(state, length) {\n    return state.expression.substr(state.index, length);\n  }\n  /**\n   * View the current character. Returns '' if end of expression is reached.\n   *\n   * @param {Object} state\n   * @returns {string}\n   * @private\n   */\n\n\n  function currentCharacter(state) {\n    return currentString(state, 1);\n  }\n  /**\n   * Get the next character from the expression.\n   * The character is stored into the char c. If the end of the expression is\n   * reached, the function puts an empty string in c.\n   * @private\n   */\n\n\n  function next(state) {\n    state.index++;\n  }\n  /**\n   * Preview the previous character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function prevCharacter(state) {\n    return state.expression.charAt(state.index - 1);\n  }\n  /**\n   * Preview the next character from the expression.\n   * @return {string} cNext\n   * @private\n   */\n\n\n  function nextCharacter(state) {\n    return state.expression.charAt(state.index + 1);\n  }\n  /**\n   * Get next token in the current string expr.\n   * The token and token type are available as token and tokenType\n   * @private\n   */\n\n\n  function getToken(state) {\n    state.tokenType = TOKENTYPE.NULL;\n    state.token = '';\n    state.comment = ''; // skip over whitespaces\n    // space, tab, and newline when inside parameters\n\n    while (parse.isWhitespace(currentCharacter(state), state.nestingLevel)) {\n      next(state);\n    } // skip comment\n\n\n    if (currentCharacter(state) === '#') {\n      while (currentCharacter(state) !== '\\n' && currentCharacter(state) !== '') {\n        state.comment += currentCharacter(state);\n        next(state);\n      }\n    } // check for end of expression\n\n\n    if (currentCharacter(state) === '') {\n      // token is still empty\n      state.tokenType = TOKENTYPE.DELIMITER;\n      return;\n    } // check for new line character\n\n\n    if (currentCharacter(state) === '\\n' && !state.nestingLevel) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = currentCharacter(state);\n      next(state);\n      return;\n    }\n\n    var c1 = currentCharacter(state);\n    var c2 = currentString(state, 2);\n    var c3 = currentString(state, 3);\n\n    if (c3.length === 3 && DELIMITERS[c3]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c3;\n      next(state);\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 2 characters\n\n\n    if (c2.length === 2 && DELIMITERS[c2]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c2;\n      next(state);\n      next(state);\n      return;\n    } // check for delimiters consisting of 1 character\n\n\n    if (DELIMITERS[c1]) {\n      state.tokenType = TOKENTYPE.DELIMITER;\n      state.token = c1;\n      next(state);\n      return;\n    } // check for a number\n\n\n    if (parse.isDigitDot(c1)) {\n      state.tokenType = TOKENTYPE.NUMBER; // check for binary, octal, or hex\n\n      var _c = currentString(state, 2);\n\n      if (_c === '0b' || _c === '0o' || _c === '0x') {\n        state.token += currentCharacter(state);\n        next(state);\n        state.token += currentCharacter(state);\n        next(state);\n\n        while (parse.isHexDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        } // check for word size suffix\n\n\n        var sign = currentCharacter(state);\n\n        if (sign === 'i') {\n          state.token += sign;\n          next(state);\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n        }\n\n        return;\n      } // get number, can have a single dot\n\n\n      if (currentCharacter(state) === '.') {\n        state.token += currentCharacter(state);\n        next(state);\n\n        if (!parse.isDigit(currentCharacter(state))) {\n          // this is no number, it is just a dot (can be dot notation)\n          state.tokenType = TOKENTYPE.DELIMITER;\n        }\n      } else {\n        while (parse.isDigit(currentCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n\n        if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n          state.token += currentCharacter(state);\n          next(state);\n        }\n      }\n\n      while (parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      } // check for exponential notation like \"2.3e-4\", \"1.23e50\" or \"2e+4\"\n\n\n      if (currentCharacter(state) === 'E' || currentCharacter(state) === 'e') {\n        if (parse.isDigit(nextCharacter(state)) || nextCharacter(state) === '-' || nextCharacter(state) === '+') {\n          state.token += currentCharacter(state);\n          next(state);\n\n          if (currentCharacter(state) === '+' || currentCharacter(state) === '-') {\n            state.token += currentCharacter(state);\n            next(state);\n          } // Scientific notation MUST be followed by an exponent\n\n\n          if (!parse.isDigit(currentCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n\n          while (parse.isDigit(currentCharacter(state))) {\n            state.token += currentCharacter(state);\n            next(state);\n          }\n\n          if (parse.isDecimalMark(currentCharacter(state), nextCharacter(state))) {\n            throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n          }\n        } else if (nextCharacter(state) === '.') {\n          next(state);\n          throw createSyntaxError(state, 'Digit expected, got \"' + currentCharacter(state) + '\"');\n        }\n      }\n\n      return;\n    } // check for variables, functions, named operators\n\n\n    if (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {\n      while (parse.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse.isDigit(currentCharacter(state))) {\n        state.token += currentCharacter(state);\n        next(state);\n      }\n\n      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {\n        state.tokenType = TOKENTYPE.DELIMITER;\n      } else {\n        state.tokenType = TOKENTYPE.SYMBOL;\n      }\n\n      return;\n    } // something unknown is found, wrong characters -> a syntax error\n\n\n    state.tokenType = TOKENTYPE.UNKNOWN;\n\n    while (currentCharacter(state) !== '') {\n      state.token += currentCharacter(state);\n      next(state);\n    }\n\n    throw createSyntaxError(state, 'Syntax error in part \"' + state.token + '\"');\n  }\n  /**\n   * Get next token and skip newline tokens\n   */\n\n\n  function getTokenSkipNewline(state) {\n    do {\n      getToken(state);\n    } while (state.token === '\\n'); // eslint-disable-line no-unmodified-loop-condition\n\n  }\n  /**\n   * Open parameters.\n   * New line characters will be ignored until closeParams(state) is called\n   */\n\n\n  function openParams(state) {\n    state.nestingLevel++;\n  }\n  /**\n   * Close parameters.\n   * New line characters will no longer be ignored\n   */\n\n\n  function closeParams(state) {\n    state.nestingLevel--;\n  }\n  /**\n   * Checks whether the current character `c` is a valid alpha character:\n   *\n   * - A latin letter (upper or lower case) Ascii: a-z, A-Z\n   * - An underscore                        Ascii: _\n   * - A dollar sign                        Ascii: $\n   * - A latin letter with accents          Unicode: \\u00C0 - \\u02AF\n   * - A greek letter                       Unicode: \\u0370 - \\u03FF\n   * - A mathematical alphanumeric symbol   Unicode: \\u{1D400} - \\u{1D7FF} excluding invalid code points\n   *\n   * The previous and next characters are needed to determine whether\n   * this character is part of a unicode surrogate pair.\n   *\n   * @param {string} c      Current character in the expression\n   * @param {string} cPrev  Previous character\n   * @param {string} cNext  Next character\n   * @return {boolean}\n   */\n\n\n  parse.isAlpha = function isAlpha(c, cPrev, cNext) {\n    return parse.isValidLatinOrGreek(c) || parse.isValidMathSymbol(c, cNext) || parse.isValidMathSymbol(cPrev, c);\n  };\n  /**\n   * Test whether a character is a valid latin, greek, or letter-like character\n   * @param {string} c\n   * @return {boolean}\n   */\n\n\n  parse.isValidLatinOrGreek = function isValidLatinOrGreek(c) {\n    return /^[a-zA-Z_$\\u00C0-\\u02AF\\u0370-\\u03FF\\u2100-\\u214F]$/.test(c);\n  };\n  /**\n   * Test whether two given 16 bit characters form a surrogate pair of a\n   * unicode math symbol.\n   *\n   * https://unicode-table.com/en/\n   * https://www.wikiwand.com/en/Mathematical_operators_and_symbols_in_Unicode\n   *\n   * Note: In ES6 will be unicode aware:\n   * https://stackoverflow.com/questions/280712/javascript-unicode-regexes\n   * https://mathiasbynens.be/notes/es6-unicode-regex\n   *\n   * @param {string} high\n   * @param {string} low\n   * @return {boolean}\n   */\n\n\n  parse.isValidMathSymbol = function isValidMathSymbol(high, low) {\n    return /^[\\uD835]$/.test(high) && /^[\\uDC00-\\uDFFF]$/.test(low) && /^[^\\uDC55\\uDC9D\\uDCA0\\uDCA1\\uDCA3\\uDCA4\\uDCA7\\uDCA8\\uDCAD\\uDCBA\\uDCBC\\uDCC4\\uDD06\\uDD0B\\uDD0C\\uDD15\\uDD1D\\uDD3A\\uDD3F\\uDD45\\uDD47-\\uDD49\\uDD51\\uDEA6\\uDEA7\\uDFCC\\uDFCD]$/.test(low);\n  };\n  /**\n   * Check whether given character c is a white space character: space, tab, or enter\n   * @param {string} c\n   * @param {number} nestingLevel\n   * @return {boolean}\n   */\n\n\n  parse.isWhitespace = function isWhitespace(c, nestingLevel) {\n    // TODO: also take '\\r' carriage return as newline? Or does that give problems on mac?\n    return c === ' ' || c === '\\t' || c === '\\n' && nestingLevel > 0;\n  };\n  /**\n   * Test whether the character c is a decimal mark (dot).\n   * This is the case when it's not the start of a delimiter '.*', './', or '.^'\n   * @param {string} c\n   * @param {string} cNext\n   * @return {boolean}\n   */\n\n\n  parse.isDecimalMark = function isDecimalMark(c, cNext) {\n    return c === '.' && cNext !== '/' && cNext !== '*' && cNext !== '^';\n  };\n  /**\n   * checks if the given char c is a digit or dot\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigitDot = function isDigitDot(c) {\n    return c >= '0' && c <= '9' || c === '.';\n  };\n  /**\n   * checks if the given char c is a digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isDigit = function isDigit(c) {\n    return c >= '0' && c <= '9';\n  };\n  /**\n   * checks if the given char c is a hex digit\n   * @param {string} c   a string with one character\n   * @return {boolean}\n   */\n\n\n  parse.isHexDigit = function isHexDigit(c) {\n    return c >= '0' && c <= '9' || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F';\n  };\n  /**\n   * Start of the parse levels below, in order of precedence\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseStart(expression, extraNodes) {\n    var state = initialState();\n\n    _extends(state, {\n      expression,\n      extraNodes\n    });\n\n    getToken(state);\n    var node = parseBlock(state); // check for garbage at the end of the expression\n    // an expression ends with a empty character '' and tokenType DELIMITER\n\n    if (state.token !== '') {\n      if (state.tokenType === TOKENTYPE.DELIMITER) {\n        // user entered a not existing operator like \"//\"\n        // TODO: give hints for aliases, for example with \"<>\" give as hint \" did you mean !== ?\"\n        throw createError(state, 'Unexpected operator ' + state.token);\n      } else {\n        throw createSyntaxError(state, 'Unexpected part \"' + state.token + '\"');\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a block with expressions. Expressions can be separated by a newline\n   * character '\\n', or by a semicolon ';'. In case of a semicolon, no output\n   * of the preceding line is returned.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBlock(state) {\n    var node;\n    var blocks = [];\n    var visible;\n\n    if (state.token !== '' && state.token !== '\\n' && state.token !== ';') {\n      node = parseAssignment(state);\n      node.comment = state.comment;\n    } // TODO: simplify this loop\n\n\n    while (state.token === '\\n' || state.token === ';') {\n      // eslint-disable-line no-unmodified-loop-condition\n      if (blocks.length === 0 && node) {\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n\n      getToken(state);\n\n      if (state.token !== '\\n' && state.token !== ';' && state.token !== '') {\n        node = parseAssignment(state);\n        node.comment = state.comment;\n        visible = state.token !== ';';\n        blocks.push({\n          node: node,\n          visible: visible\n        });\n      }\n    }\n\n    if (blocks.length > 0) {\n      return new BlockNode(blocks);\n    } else {\n      if (!node) {\n        node = new ConstantNode(undefined);\n        node.comment = state.comment;\n      }\n\n      return node;\n    }\n  }\n  /**\n   * Assignment of a function or variable,\n   * - can be a variable like 'a=2.3'\n   * - or a updating an existing variable like 'matrix(2,3:5)=[6,7,8]'\n   * - defining a function like 'f(x) = x^2'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAssignment(state) {\n    var name, args, value, valid;\n    var node = parseConditional(state);\n\n    if (state.token === '=') {\n      if (isSymbolNode(node)) {\n        // parse a variable assignment like 'a = 2/3'\n        name = node.name;\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(new SymbolNode(name), value);\n      } else if (isAccessorNode(node)) {\n        // parse a matrix subset assignment like 'A[1,2] = 4'\n        getTokenSkipNewline(state);\n        value = parseAssignment(state);\n        return new AssignmentNode(node.object, node.index, value);\n      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {\n        // parse function assignment like 'f(x) = x^2'\n        valid = true;\n        args = [];\n        name = node.name;\n        node.args.forEach(function (arg, index) {\n          if (isSymbolNode(arg)) {\n            args[index] = arg.name;\n          } else {\n            valid = false;\n          }\n        });\n\n        if (valid) {\n          getTokenSkipNewline(state);\n          value = parseAssignment(state);\n          return new FunctionAssignmentNode(name, args, value);\n        }\n      }\n\n      throw createSyntaxError(state, 'Invalid left hand side of assignment operator =');\n    }\n\n    return node;\n  }\n  /**\n   * conditional operation\n   *\n   *     condition ? truePart : falsePart\n   *\n   * Note: conditional operator is right-associative\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConditional(state) {\n    var node = parseLogicalOr(state);\n\n    while (state.token === '?') {\n      // eslint-disable-line no-unmodified-loop-condition\n      // set a conditional level, the range operator will be ignored as long\n      // as conditionalLevel === state.nestingLevel.\n      var prev = state.conditionalLevel;\n      state.conditionalLevel = state.nestingLevel;\n      getTokenSkipNewline(state);\n      var condition = node;\n      var trueExpr = parseAssignment(state);\n      if (state.token !== ':') throw createSyntaxError(state, 'False part of conditional expression expected');\n      state.conditionalLevel = null;\n      getTokenSkipNewline(state);\n      var falseExpr = parseAssignment(state); // Note: check for conditional operator again, right associativity\n\n      node = new ConditionalNode(condition, trueExpr, falseExpr); // restore the previous conditional level\n\n      state.conditionalLevel = prev;\n    }\n\n    return node;\n  }\n  /**\n   * logical or, 'x or y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalOr(state) {\n    var node = parseLogicalXor(state);\n\n    while (state.token === 'or') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('or', 'or', [node, parseLogicalXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical exclusive or, 'x xor y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalXor(state) {\n    var node = parseLogicalAnd(state);\n\n    while (state.token === 'xor') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('xor', 'xor', [node, parseLogicalAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * logical and, 'x and y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLogicalAnd(state) {\n    var node = parseBitwiseOr(state);\n\n    while (state.token === 'and') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('and', 'and', [node, parseBitwiseOr(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise or, 'x | y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseOr(state) {\n    var node = parseBitwiseXor(state);\n\n    while (state.token === '|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('|', 'bitOr', [node, parseBitwiseXor(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise exclusive or (xor), 'x ^| y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseXor(state) {\n    var node = parseBitwiseAnd(state);\n\n    while (state.token === '^|') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('^|', 'bitXor', [node, parseBitwiseAnd(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * bitwise and, 'x & y'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseBitwiseAnd(state) {\n    var node = parseRelational(state);\n\n    while (state.token === '&') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getTokenSkipNewline(state);\n      node = new OperatorNode('&', 'bitAnd', [node, parseRelational(state)]);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a chained conditional, like 'a > b >= c'\n   * @return {Node} node\n   */\n\n\n  function parseRelational(state) {\n    var params = [parseShift(state)];\n    var conditionals = [];\n    var operators = {\n      '==': 'equal',\n      '!=': 'unequal',\n      '<': 'smaller',\n      '>': 'larger',\n      '<=': 'smallerEq',\n      '>=': 'largerEq'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      var cond = {\n        name: state.token,\n        fn: operators[state.token]\n      };\n      conditionals.push(cond);\n      getTokenSkipNewline(state);\n      params.push(parseShift(state));\n    }\n\n    if (params.length === 1) {\n      return params[0];\n    } else if (params.length === 2) {\n      return new OperatorNode(conditionals[0].name, conditionals[0].fn, params);\n    } else {\n      return new RelationalNode(conditionals.map(c => c.fn), params);\n    }\n  }\n  /**\n   * Bitwise left shift, bitwise right arithmetic shift, bitwise right logical shift\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseShift(state) {\n    var node, name, fn, params;\n    node = parseConversion(state);\n    var operators = {\n      '<<': 'leftShift',\n      '>>': 'rightArithShift',\n      '>>>': 'rightLogShift'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseConversion(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * conversion operators 'to' and 'in'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseConversion(state) {\n    var node, name, fn, params;\n    node = parseRange(state);\n    var operators = {\n      to: 'to',\n      in: 'to' // alias of 'to'\n\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n\n      if (name === 'in' && state.token === '') {\n        // end of expression -> this is the unit 'in' ('inch')\n        node = new OperatorNode('*', 'multiply', [node, new SymbolNode('in')], true);\n      } else {\n        // operator 'a to b' or 'a in b'\n        params = [node, parseRange(state)];\n        node = new OperatorNode(name, fn, params);\n      }\n    }\n\n    return node;\n  }\n  /**\n   * parse range, \"start:end\", \"start:step:end\", \":\", \"start:\", \":end\", etc\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRange(state) {\n    var node;\n    var params = [];\n\n    if (state.token === ':') {\n      // implicit start=1 (one-based)\n      node = new ConstantNode(1);\n    } else {\n      // explicit start\n      node = parseAddSubtract(state);\n    }\n\n    if (state.token === ':' && state.conditionalLevel !== state.nestingLevel) {\n      // we ignore the range operator when a conditional operator is being processed on the same level\n      params.push(node); // parse step and end\n\n      while (state.token === ':' && params.length < 3) {\n        // eslint-disable-line no-unmodified-loop-condition\n        getTokenSkipNewline(state);\n\n        if (state.token === ')' || state.token === ']' || state.token === ',' || state.token === '') {\n          // implicit end\n          params.push(new SymbolNode('end'));\n        } else {\n          // explicit end\n          params.push(parseAddSubtract(state));\n        }\n      }\n\n      if (params.length === 3) {\n        // params = [start, step, end]\n        node = new RangeNode(params[0], params[2], params[1]); // start, end, step\n      } else {\n        // length === 2\n        // params = [start, end]\n        node = new RangeNode(params[0], params[1]); // start, end\n      }\n    }\n\n    return node;\n  }\n  /**\n   * add or subtract\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAddSubtract(state) {\n    var node, name, fn, params;\n    node = parseMultiplyDivide(state);\n    var operators = {\n      '+': 'add',\n      '-': 'subtract'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getTokenSkipNewline(state);\n      params = [node, parseMultiplyDivide(state)];\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * multiply, divide, modulus\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMultiplyDivide(state) {\n    var node, last, name, fn;\n    node = parseImplicitMultiplication(state);\n    last = node;\n    var operators = {\n      '*': 'multiply',\n      '.*': 'dotMultiply',\n      '/': 'divide',\n      './': 'dotDivide',\n      '%': 'mod',\n      mod: 'mod'\n    };\n\n    while (true) {\n      if (hasOwnProperty(operators, state.token)) {\n        // explicit operators\n        name = state.token;\n        fn = operators[name];\n        getTokenSkipNewline(state);\n        last = parseImplicitMultiplication(state);\n        node = new OperatorNode(name, fn, [node, last]);\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * implicit multiplication\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseImplicitMultiplication(state) {\n    var node, last;\n    node = parseRule2(state);\n    last = node;\n\n    while (true) {\n      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === 'in' && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === '!') || state.token === '(') {\n        // parse implicit multiplication\n        //\n        // symbol:      implicit multiplication like '2a', '(2+3)a', 'a b'\n        // number:      implicit multiplication like '(2+3)2'\n        // parenthesis: implicit multiplication like '2(3+4)', '(3+4)(1+2)'\n        last = parseRule2(state);\n        node = new OperatorNode('*', 'multiply', [node, last], true\n        /* implicit */\n        );\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Infamous \"rule 2\" as described in https://github.com/josdejong/mathjs/issues/792#issuecomment-361065370\n   * Explicit division gets higher precedence than implicit multiplication\n   * when the division matches this pattern: [number] / [number] [symbol]\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseRule2(state) {\n    var node = parseUnary(state);\n    var last = node;\n    var tokenStates = [];\n\n    while (true) {\n      // Match the \"number /\" part of the pattern \"number / number symbol\"\n      if (state.token === '/' && isConstantNode(last)) {\n        // Look ahead to see if the next token is a number\n        tokenStates.push(_extends({}, state));\n        getTokenSkipNewline(state); // Match the \"number / number\" part of the pattern\n\n        if (state.tokenType === TOKENTYPE.NUMBER) {\n          // Look ahead again\n          tokenStates.push(_extends({}, state));\n          getTokenSkipNewline(state); // Match the \"symbol\" part of the pattern, or a left parenthesis\n\n          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === '(') {\n            // We've matched the pattern \"number / number symbol\".\n            // Rewind once and build the \"number / number\" node; the symbol will be consumed later\n            _extends(state, tokenStates.pop());\n\n            tokenStates.pop();\n            last = parseUnary(state);\n            node = new OperatorNode('/', 'divide', [node, last]);\n          } else {\n            // Not a match, so rewind\n            tokenStates.pop();\n\n            _extends(state, tokenStates.pop());\n\n            break;\n          }\n        } else {\n          // Not a match, so rewind\n          _extends(state, tokenStates.pop());\n\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Unary plus and minus, and logical and bitwise not\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseUnary(state) {\n    var name, params, fn;\n    var operators = {\n      '-': 'unaryMinus',\n      '+': 'unaryPlus',\n      '~': 'bitNot',\n      not: 'not'\n    };\n\n    if (hasOwnProperty(operators, state.token)) {\n      fn = operators[state.token];\n      name = state.token;\n      getTokenSkipNewline(state);\n      params = [parseUnary(state)];\n      return new OperatorNode(name, fn, params);\n    }\n\n    return parsePow(state);\n  }\n  /**\n   * power\n   * Note: power operator is right associative\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parsePow(state) {\n    var node, name, fn, params;\n    node = parseLeftHandOperators(state);\n\n    if (state.token === '^' || state.token === '.^') {\n      name = state.token;\n      fn = name === '^' ? 'pow' : 'dotPow';\n      getTokenSkipNewline(state);\n      params = [node, parseUnary(state)]; // Go back to unary, we can have '2^-3'\n\n      node = new OperatorNode(name, fn, params);\n    }\n\n    return node;\n  }\n  /**\n   * Left hand operators: factorial x!, ctranspose x'\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseLeftHandOperators(state) {\n    var node, name, fn, params;\n    node = parseCustomNodes(state);\n    var operators = {\n      '!': 'factorial',\n      '\\'': 'ctranspose'\n    };\n\n    while (hasOwnProperty(operators, state.token)) {\n      name = state.token;\n      fn = operators[name];\n      getToken(state);\n      params = [node];\n      node = new OperatorNode(name, fn, params);\n      node = parseAccessors(state, node);\n    }\n\n    return node;\n  }\n  /**\n   * Parse a custom node handler. A node handler can be used to process\n   * nodes in a custom way, for example for handling a plot.\n   *\n   * A handler must be passed as second argument of the parse function.\n   * - must extend math.Node\n   * - must contain a function _compile(defs: Object) : string\n   * - must contain a function find(filter: Object) : Node[]\n   * - must contain a function toString() : string\n   * - the constructor is called with a single argument containing all parameters\n   *\n   * For example:\n   *\n   *     nodes = {\n   *       'plot': PlotHandler\n   *     }\n   *\n   * The constructor of the handler is called as:\n   *\n   *     node = new PlotHandler(params)\n   *\n   * The handler will be invoked when evaluating an expression like:\n   *\n   *     node = math.parse('plot(sin(x), x)', nodes)\n   *\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseCustomNodes(state) {\n    var params = [];\n\n    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {\n      var CustomNode = state.extraNodes[state.token];\n      getToken(state); // parse parameters\n\n      if (state.token === '(') {\n        params = [];\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ')') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ')') {\n          throw createSyntaxError(state, 'Parenthesis ) expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n      } // create a new custom node\n      // noinspection JSValidateTypes\n\n\n      return new CustomNode(params);\n    }\n\n    return parseSymbol(state);\n  }\n  /**\n   * parse symbols: functions, variables, constants, units\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSymbol(state) {\n    var node, name;\n\n    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n      name = state.token;\n      getToken(state);\n\n      if (hasOwnProperty(CONSTANTS, name)) {\n        // true, false, null, ...\n        node = new ConstantNode(CONSTANTS[name]);\n      } else if (NUMERIC_CONSTANTS.indexOf(name) !== -1) {\n        // NaN, Infinity\n        node = new ConstantNode(numeric(name, 'number'));\n      } else {\n        node = new SymbolNode(name);\n      } // parse function parameters and matrix index\n\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseDoubleQuotesString(state);\n  }\n  /**\n   * parse accessors:\n   * - function invocation in round brackets (...), for example sqrt(2)\n   * - index enclosed in square brackets [...], for example A[2,3]\n   * - dot notation for properties, like foo.bar\n   * @param {Object} state\n   * @param {Node} node    Node on which to apply the parameters. If there\n   *                       are no parameters in the expression, the node\n   *                       itself is returned\n   * @param {string[]} [types]  Filter the types of notations\n   *                            can be ['(', '[', '.']\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseAccessors(state, node, types) {\n    var params;\n\n    while ((state.token === '(' || state.token === '[' || state.token === '.') && (!types || types.indexOf(state.token) !== -1)) {\n      // eslint-disable-line no-unmodified-loop-condition\n      params = [];\n\n      if (state.token === '(') {\n        if (isSymbolNode(node) || isAccessorNode(node)) {\n          // function invocation like fn(2, 3) or obj.fn(2, 3)\n          openParams(state);\n          getToken(state);\n\n          if (state.token !== ')') {\n            params.push(parseAssignment(state)); // parse a list with parameters\n\n            while (state.token === ',') {\n              // eslint-disable-line no-unmodified-loop-condition\n              getToken(state);\n              params.push(parseAssignment(state));\n            }\n          }\n\n          if (state.token !== ')') {\n            throw createSyntaxError(state, 'Parenthesis ) expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          node = new FunctionNode(node, params);\n        } else {\n          // implicit multiplication like (2+3)(4+5) or sqrt(2)(1+2)\n          // don't parse it here but let it be handled by parseImplicitMultiplication\n          // with correct precedence\n          return node;\n        }\n      } else if (state.token === '[') {\n        // index notation like variable[2, 3]\n        openParams(state);\n        getToken(state);\n\n        if (state.token !== ']') {\n          params.push(parseAssignment(state)); // parse a list with parameters\n\n          while (state.token === ',') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params.push(parseAssignment(state));\n          }\n        }\n\n        if (state.token !== ']') {\n          throw createSyntaxError(state, 'Parenthesis ] expected');\n        }\n\n        closeParams(state);\n        getToken(state);\n        node = new AccessorNode(node, new IndexNode(params));\n      } else {\n        // dot notation like variable.prop\n        getToken(state);\n\n        if (state.tokenType !== TOKENTYPE.SYMBOL) {\n          throw createSyntaxError(state, 'Property name expected after dot');\n        }\n\n        params.push(new ConstantNode(state.token));\n        getToken(state);\n        var dotNotation = true;\n        node = new AccessorNode(node, new IndexNode(params, dotNotation));\n      }\n    }\n\n    return node;\n  }\n  /**\n   * Parse a double quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseDoubleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\"') {\n      str = parseDoubleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseSingleQuotesString(state);\n  }\n  /**\n   * Parse a string surrounded by double quotes \"...\"\n   * @return {string}\n   */\n\n\n  function parseDoubleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\"') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\\"'\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\"') {\n      throw createSyntaxError(state, 'End of string \" expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * Parse a single quotes string.\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseSingleQuotesString(state) {\n    var node, str;\n\n    if (state.token === '\\'') {\n      str = parseSingleQuotesStringToken(state); // create constant\n\n      node = new ConstantNode(str); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseMatrix(state);\n  }\n  /**\n   * Parse a string surrounded by single quotes '...'\n   * @return {string}\n   */\n\n\n  function parseSingleQuotesStringToken(state) {\n    var str = '';\n\n    while (currentCharacter(state) !== '' && currentCharacter(state) !== '\\'') {\n      if (currentCharacter(state) === '\\\\') {\n        // escape character, immediately process the next\n        // character to prevent stopping at a next '\\''\n        str += currentCharacter(state);\n        next(state);\n      }\n\n      str += currentCharacter(state);\n      next(state);\n    }\n\n    getToken(state);\n\n    if (state.token !== '\\'') {\n      throw createSyntaxError(state, 'End of string \\' expected');\n    }\n\n    getToken(state);\n    return JSON.parse('\"' + str + '\"'); // unescape escaped characters\n  }\n  /**\n   * parse the matrix\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseMatrix(state) {\n    var array, params, rows, cols;\n\n    if (state.token === '[') {\n      // matrix [...]\n      openParams(state);\n      getToken(state);\n\n      if (state.token !== ']') {\n        // this is a non-empty matrix\n        var row = parseRow(state);\n\n        if (state.token === ';') {\n          // 2 dimensional array\n          rows = 1;\n          params = [row]; // the rows of the matrix are separated by dot-comma's\n\n          while (state.token === ';') {\n            // eslint-disable-line no-unmodified-loop-condition\n            getToken(state);\n            params[rows] = parseRow(state);\n            rows++;\n          }\n\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state); // check if the number of columns matches in all rows\n\n          cols = params[0].items.length;\n\n          for (var r = 1; r < rows; r++) {\n            if (params[r].items.length !== cols) {\n              throw createError(state, 'Column dimensions mismatch ' + '(' + params[r].items.length + ' !== ' + cols + ')');\n            }\n          }\n\n          array = new ArrayNode(params);\n        } else {\n          // 1 dimensional vector\n          if (state.token !== ']') {\n            throw createSyntaxError(state, 'End of matrix ] expected');\n          }\n\n          closeParams(state);\n          getToken(state);\n          array = row;\n        }\n      } else {\n        // this is an empty matrix \"[ ]\"\n        closeParams(state);\n        getToken(state);\n        array = new ArrayNode([]);\n      }\n\n      return parseAccessors(state, array);\n    }\n\n    return parseObject(state);\n  }\n  /**\n   * Parse a single comma-separated row from a matrix, like 'a, b, c'\n   * @return {ArrayNode} node\n   */\n\n\n  function parseRow(state) {\n    var params = [parseAssignment(state)];\n    var len = 1;\n\n    while (state.token === ',') {\n      // eslint-disable-line no-unmodified-loop-condition\n      getToken(state); // parse expression\n\n      params[len] = parseAssignment(state);\n      len++;\n    }\n\n    return new ArrayNode(params);\n  }\n  /**\n   * parse an object, enclosed in angle brackets{...}, for example {value: 2}\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseObject(state) {\n    if (state.token === '{') {\n      openParams(state);\n      var key;\n      var properties = {};\n\n      do {\n        getToken(state);\n\n        if (state.token !== '}') {\n          // parse key\n          if (state.token === '\"') {\n            key = parseDoubleQuotesStringToken(state);\n          } else if (state.token === '\\'') {\n            key = parseSingleQuotesStringToken(state);\n          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {\n            key = state.token;\n            getToken(state);\n          } else {\n            throw createSyntaxError(state, 'Symbol or string expected as object key');\n          } // parse key/value separator\n\n\n          if (state.token !== ':') {\n            throw createSyntaxError(state, 'Colon : expected after object key');\n          }\n\n          getToken(state); // parse key\n\n          properties[key] = parseAssignment(state);\n        }\n      } while (state.token === ','); // eslint-disable-line no-unmodified-loop-condition\n\n\n      if (state.token !== '}') {\n        throw createSyntaxError(state, 'Comma , or bracket } expected after object value');\n      }\n\n      closeParams(state);\n      getToken(state);\n      var node = new ObjectNode(properties); // parse index parameters\n\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseNumber(state);\n  }\n  /**\n   * parse a number\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseNumber(state) {\n    var numberStr;\n\n    if (state.tokenType === TOKENTYPE.NUMBER) {\n      // this is a number\n      numberStr = state.token;\n      getToken(state);\n      return new ConstantNode(numeric(numberStr, config.number));\n    }\n\n    return parseParentheses(state);\n  }\n  /**\n   * parentheses\n   * @return {Node} node\n   * @private\n   */\n\n\n  function parseParentheses(state) {\n    var node; // check if it is a parenthesized expression\n\n    if (state.token === '(') {\n      // parentheses (...)\n      openParams(state);\n      getToken(state);\n      node = parseAssignment(state); // start again\n\n      if (state.token !== ')') {\n        throw createSyntaxError(state, 'Parenthesis ) expected');\n      }\n\n      closeParams(state);\n      getToken(state);\n      node = new ParenthesisNode(node);\n      node = parseAccessors(state, node);\n      return node;\n    }\n\n    return parseEnd(state);\n  }\n  /**\n   * Evaluated when the expression is not yet ended but expected to end\n   * @return {Node} res\n   * @private\n   */\n\n\n  function parseEnd(state) {\n    if (state.token === '') {\n      // syntax error or unexpected end of expression\n      throw createSyntaxError(state, 'Unexpected end of expression');\n    } else {\n      throw createSyntaxError(state, 'Value expected');\n    }\n  }\n  /**\n   * Shortcut for getting the current row value (one based)\n   * Returns the line of the currently handled expression\n   * @private\n   */\n\n  /* TODO: implement keeping track on the row number\n  function row () {\n    return null\n  }\n  */\n\n  /**\n   * Shortcut for getting the current col value (one based)\n   * Returns the column (position) where the last state.token starts\n   * @private\n   */\n\n\n  function col(state) {\n    return state.index - state.token.length + 1;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {SyntaxError} instantiated error\n   * @private\n   */\n\n\n  function createSyntaxError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n  /**\n   * Create an error\n   * @param {Object} state\n   * @param {string} message\n   * @return {Error} instantiated error\n   * @private\n   */\n\n\n  function createError(state, message) {\n    var c = col(state);\n    var error = new SyntaxError(message + ' (char ' + c + ')');\n    error.char = c;\n    return error;\n  }\n\n  return parse;\n});"]},"metadata":{},"sourceType":"module"}