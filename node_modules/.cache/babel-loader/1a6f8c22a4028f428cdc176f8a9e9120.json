{"ast":null,"code":"import { isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    var s = '\\\\begin{bmatrix}';\n    this.items.forEach(function (node) {\n      if (node.items) {\n        s += node.items.map(function (childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      } else {\n        s += node.toTex(options);\n      } // new line\n\n\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/Users/elimunn/Desktop/plot-recipes/node_modules/mathjs/lib/esm/expression/node/ArrayNode.js"],"names":["isNode","map","factory","name","dependencies","createArrayNode","_ref","Node","ArrayNode","items","SyntaxError","Array","isArray","every","TypeError","prototype","type","isArrayNode","_compile","math","argNames","evalItems","item","asMatrix","config","matrix","evalArrayNode","scope","args","context","evalItem","forEach","callback","i","length","node","_ifNode","clone","slice","_toString","options","toString","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","s","childNode","toTex","isClass"],"mappings":"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","sourcesContent":["import { isNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'ArrayNode';\nvar dependencies = ['Node'];\nexport var createArrayNode = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * @constructor ArrayNode\n   * @extends {Node}\n   * Holds an 1-dimensional array with items\n   * @param {Node[]} [items]   1 dimensional array with items\n   */\n  function ArrayNode(items) {\n    if (!(this instanceof ArrayNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.items = items || []; // validate input\n\n    if (!Array.isArray(this.items) || !this.items.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected');\n    }\n  }\n\n  ArrayNode.prototype = new Node();\n  ArrayNode.prototype.type = 'ArrayNode';\n  ArrayNode.prototype.isArrayNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  ArrayNode.prototype._compile = function (math, argNames) {\n    var evalItems = map(this.items, function (item) {\n      return item._compile(math, argNames);\n    });\n    var asMatrix = math.config.matrix !== 'Array';\n\n    if (asMatrix) {\n      var matrix = math.matrix;\n      return function evalArrayNode(scope, args, context) {\n        return matrix(map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        }));\n      };\n    } else {\n      return function evalArrayNode(scope, args, context) {\n        return map(evalItems, function (evalItem) {\n          return evalItem(scope, args, context);\n        });\n      };\n    }\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  ArrayNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.items.length; i++) {\n      var node = this.items[i];\n      callback(node, 'items[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new ArrayNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {ArrayNode} Returns a transformed copy of the node\n   */\n\n\n  ArrayNode.prototype.map = function (callback) {\n    var items = [];\n\n    for (var i = 0; i < this.items.length; i++) {\n      items[i] = this._ifNode(callback(this.items[i], 'items[' + i + ']', this));\n    }\n\n    return new ArrayNode(items);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {ArrayNode}\n   */\n\n\n  ArrayNode.prototype.clone = function () {\n    return new ArrayNode(this.items.slice(0));\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype._toString = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toString(options);\n    });\n    return '[' + items.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  ArrayNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'ArrayNode',\n      items: this.items\n    };\n  };\n  /**\n   * Instantiate an ArrayNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"ArrayNode\", items: [...]}`,\n   *                       where mathjs is optional\n   * @returns {ArrayNode}\n   */\n\n\n  ArrayNode.fromJSON = function (json) {\n    return new ArrayNode(json.items);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   * @override\n   */\n\n\n  ArrayNode.prototype.toHTML = function (options) {\n    var items = this.items.map(function (node) {\n      return node.toHTML(options);\n    });\n    return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + items.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  ArrayNode.prototype._toTex = function (options) {\n    var s = '\\\\begin{bmatrix}';\n    this.items.forEach(function (node) {\n      if (node.items) {\n        s += node.items.map(function (childNode) {\n          return childNode.toTex(options);\n        }).join('&');\n      } else {\n        s += node.toTex(options);\n      } // new line\n\n\n      s += '\\\\\\\\';\n    });\n    s += '\\\\end{bmatrix}';\n    return s;\n  };\n\n  return ArrayNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}