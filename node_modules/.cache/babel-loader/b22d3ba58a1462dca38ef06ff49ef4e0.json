{"ast":null,"code":"import { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Node\n  } = _ref;\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(p => p._compile(math, argNames));\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/Users/elimunn/Desktop/plot-recipes/node_modules/mathjs/lib/esm/expression/node/RelationalNode.js"],"names":["getPrecedence","escape","getSafeProperty","latexOperators","factory","name","dependencies","createRelationalNode","_ref","Node","RelationalNode","conditionals","params","SyntaxError","Array","isArray","TypeError","length","prototype","type","isRelationalNode","_compile","math","argNames","self","compiled","map","p","evalRelationalNode","scope","args","context","evalLhs","evalRhs","i","condFn","forEach","callback","n","slice","_ifNode","clone","_toString","options","parenthesis","precedence","paramStrings","index","paramPrecedence","toString","operatorMap","equal","unequal","smaller","larger","smallerEq","largerEq","ret","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","isClass","isNode"],"mappings":"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","sourcesContent":["import { getPrecedence } from '../operators.js';\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { latexOperators } from '../../utils/latex.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'RelationalNode';\nvar dependencies = ['Node'];\nexport var createRelationalNode = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    Node\n  } = _ref;\n\n  /**\n   * A node representing a chained conditional expression, such as 'x > y > z'\n   *\n   * @param {String[]} conditionals   An array of conditional operators used to compare the parameters\n   * @param {Node[]} params   The parameters that will be compared\n   *\n   * @constructor RelationalNode\n   * @extends {Node}\n   */\n  function RelationalNode(conditionals, params) {\n    if (!(this instanceof RelationalNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    if (!Array.isArray(conditionals)) throw new TypeError('Parameter conditionals must be an array');\n    if (!Array.isArray(params)) throw new TypeError('Parameter params must be an array');\n    if (conditionals.length !== params.length - 1) throw new TypeError('Parameter params must contain exactly one more element than parameter conditionals');\n    this.conditionals = conditionals;\n    this.params = params;\n  }\n\n  RelationalNode.prototype = new Node();\n  RelationalNode.prototype.type = 'RelationalNode';\n  RelationalNode.prototype.isRelationalNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  RelationalNode.prototype._compile = function (math, argNames) {\n    var self = this;\n    var compiled = this.params.map(p => p._compile(math, argNames));\n    return function evalRelationalNode(scope, args, context) {\n      var evalLhs;\n      var evalRhs = compiled[0](scope, args, context);\n\n      for (var i = 0; i < self.conditionals.length; i++) {\n        evalLhs = evalRhs;\n        evalRhs = compiled[i + 1](scope, args, context);\n        var condFn = getSafeProperty(math, self.conditionals[i]);\n\n        if (!condFn(evalLhs, evalRhs)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  RelationalNode.prototype.forEach = function (callback) {\n    this.params.forEach((n, i) => callback(n, 'params[' + i + ']', this), this);\n  };\n  /**\n   * Create a new RelationalNode having its childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {RelationalNode} Returns a transformed copy of the node\n   */\n\n\n  RelationalNode.prototype.map = function (callback) {\n    return new RelationalNode(this.conditionals.slice(), this.params.map((n, i) => this._ifNode(callback(n, 'params[' + i + ']', this)), this));\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {RelationalNode}\n   */\n\n\n  RelationalNode.prototype.clone = function () {\n    return new RelationalNode(this.conditionals, this.params);\n  };\n  /**\n   * Get string representation.\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toString = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '(' + p.toString(options) + ')' : p.toString(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += ' ' + operatorMap[this.conditionals[i]] + ' ' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  RelationalNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'RelationalNode',\n      conditionals: this.conditionals,\n      params: this.params\n    };\n  };\n  /**\n   * Instantiate a RelationalNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"RelationalNode\", \"condition\": ..., \"trueExpr\": ..., \"falseExpr\": ...}`,\n   *                       where mathjs is optional\n   * @returns {RelationalNode}\n   */\n\n\n  RelationalNode.fromJSON = function (json) {\n    return new RelationalNode(json.conditionals, json.params);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype.toHTML = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class=\"math-parenthesis math-round-parenthesis\">(</span>' + p.toHTML(options) + '<span class=\"math-parenthesis math-round-parenthesis\">)</span>' : p.toHTML(options);\n    });\n    var operatorMap = {\n      equal: '==',\n      unequal: '!=',\n      smaller: '<',\n      larger: '>',\n      smallerEq: '<=',\n      largerEq: '>='\n    };\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += '<span class=\"math-operator math-binary-operator math-explicit-binary-operator\">' + escape(operatorMap[this.conditionals[i]]) + '</span>' + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  RelationalNode.prototype._toTex = function (options) {\n    var parenthesis = options && options.parenthesis ? options.parenthesis : 'keep';\n    var precedence = getPrecedence(this, parenthesis);\n    var paramStrings = this.params.map(function (p, index) {\n      var paramPrecedence = getPrecedence(p, parenthesis);\n      return parenthesis === 'all' || paramPrecedence !== null && paramPrecedence <= precedence ? '\\\\left(' + p.toTex(options) + '\\right)' : p.toTex(options);\n    });\n    var ret = paramStrings[0];\n\n    for (var i = 0; i < this.conditionals.length; i++) {\n      ret += latexOperators[this.conditionals[i]] + paramStrings[i + 1];\n    }\n\n    return ret;\n  };\n\n  return RelationalNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}