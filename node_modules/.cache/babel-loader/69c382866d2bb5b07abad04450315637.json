{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) : typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) : (global = global || self, factory(global.swipeable = {}, global.react));\n})(this, function (exports, React) {\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  var LEFT = \"Left\";\n  var RIGHT = \"Right\";\n  var UP = \"Up\";\n  var DOWN = \"Down\";\n  var defaultProps = {\n    delta: 10,\n    preventDefaultTouchmoveEvent: false,\n    rotationAngle: 0,\n    trackMouse: false,\n    trackTouch: true\n  };\n  var initialState = {\n    first: true,\n    initial: [0, 0],\n    start: 0,\n    swiping: false,\n    xy: [0, 0]\n  };\n  var mouseMove = \"mousemove\";\n  var mouseUp = \"mouseup\";\n  var touchEnd = \"touchend\";\n  var touchMove = \"touchmove\";\n  var touchStart = \"touchstart\";\n\n  function getDirection(absX, absY, deltaX, deltaY) {\n    if (absX > absY) {\n      if (deltaX > 0) {\n        return RIGHT;\n      }\n\n      return LEFT;\n    } else if (deltaY > 0) {\n      return DOWN;\n    }\n\n    return UP;\n  }\n\n  function rotateXYByAngle(pos, angle) {\n    if (angle === 0) return pos;\n    var angleInRadians = Math.PI / 180 * angle;\n    var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n    var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n    return [x, y];\n  }\n\n  function getHandlers(set, handlerProps) {\n    var onStart = function onStart(event) {\n      // if more than a single touch don't track, for now...\n      if (event && \"touches\" in event && event.touches.length > 1) return;\n      set(function (state, props) {\n        // setup mouse listeners on document to track swipe since swipe can leave container\n        if (props.trackMouse) {\n          document.addEventListener(mouseMove, onMove);\n          document.addEventListener(mouseUp, onUp);\n        }\n\n        var _ref = \"touches\" in event ? event.touches[0] : event,\n            clientX = _ref.clientX,\n            clientY = _ref.clientY;\n\n        var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n        return _extends({}, state, initialState, {\n          initial: [].concat(xy),\n          xy: xy,\n          start: event.timeStamp || 0\n        });\n      });\n    };\n\n    var onMove = function onMove(event) {\n      set(function (state, props) {\n        // Discount a swipe if additional touches are present after\n        // a swipe has started.\n        if (\"touches\" in event && event.touches.length > 1) {\n          return state;\n        }\n\n        var _ref2 = \"touches\" in event ? event.touches[0] : event,\n            clientX = _ref2.clientX,\n            clientY = _ref2.clientY;\n\n        var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),\n            x = _rotateXYByAngle[0],\n            y = _rotateXYByAngle[1];\n\n        var deltaX = x - state.xy[0];\n        var deltaY = y - state.xy[1];\n        var absX = Math.abs(deltaX);\n        var absY = Math.abs(deltaY);\n        var time = (event.timeStamp || 0) - state.start;\n        var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n        var vxvy = [deltaX / (time || 1), deltaY / (time || 1)]; // if swipe is under delta and we have not started to track a swipe: skip update\n\n        if (absX < props.delta && absY < props.delta && !state.swiping) return state;\n        var dir = getDirection(absX, absY, deltaX, deltaY);\n        var eventData = {\n          absX: absX,\n          absY: absY,\n          deltaX: deltaX,\n          deltaY: deltaY,\n          dir: dir,\n          event: event,\n          first: state.first,\n          initial: state.initial,\n          velocity: velocity,\n          vxvy: vxvy\n        };\n        props.onSwiping && props.onSwiping(eventData); // track if a swipe is cancelable(handler for swiping or swiped(dir) exists)\n        // so we can call preventDefault if needed\n\n        var cancelablePageSwipe = false;\n\n        if (props.onSwiping || props.onSwiped || \"onSwiped\" + dir in props) {\n          cancelablePageSwipe = true;\n        }\n\n        if (cancelablePageSwipe && props.preventDefaultTouchmoveEvent && props.trackTouch && event.cancelable) event.preventDefault();\n        return _extends({}, state, {\n          // first is now always false\n          first: false,\n          eventData: eventData,\n          swiping: true\n        });\n      });\n    };\n\n    var onEnd = function onEnd(event) {\n      set(function (state, props) {\n        var eventData;\n\n        if (state.swiping && state.eventData) {\n          eventData = _extends({}, state.eventData, {\n            event: event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          var onSwipedDir = \"onSwiped\" + eventData.dir;\n\n          if (onSwipedDir in props) {\n            props[onSwipedDir](eventData);\n          }\n        } else {\n          props.onTap && props.onTap({\n            event: event\n          });\n        }\n\n        return _extends({}, state, initialState, {\n          eventData: eventData\n        });\n      });\n    };\n\n    var cleanUpMouse = function cleanUpMouse() {\n      // safe to just call removeEventListener\n      document.removeEventListener(mouseMove, onMove);\n      document.removeEventListener(mouseUp, onUp);\n    };\n\n    var onUp = function onUp(e) {\n      cleanUpMouse();\n      onEnd(e);\n    };\n    /**\r\n     * Switch of \"passive\" property for now.\r\n     * When `preventDefaultTouchmoveEvent` is:\r\n     * - true => { passive: false }\r\n     * - false => { passive: true }\r\n     *\r\n     * Could take entire `addEventListener` options object as a param later?\r\n     */\n\n\n    var attachTouch = function attachTouch(el, passive) {\n      var cleanup = function cleanup() {};\n\n      if (el && el.addEventListener) {\n        // attach touch event listeners and handlers\n        var tls = [[touchStart, onStart], [touchMove, onMove], [touchEnd, onEnd]];\n        tls.forEach(function (_ref3) {\n          var e = _ref3[0],\n              h = _ref3[1];\n          return el.addEventListener(e, h, {\n            passive: passive\n          });\n        }); // return properly scoped cleanup method for removing listeners, options not required\n\n        cleanup = function cleanup() {\n          return tls.forEach(function (_ref4) {\n            var e = _ref4[0],\n                h = _ref4[1];\n            return el.removeEventListener(e, h);\n          });\n        };\n      }\n\n      return cleanup;\n    };\n\n    var onRef = function onRef(el) {\n      // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n      // ignore null here\n      if (el === null) return;\n      set(function (state, props) {\n        // if the same DOM el as previous just return state\n        if (state.el === el) return state;\n        var addState = {}; // if new DOM el clean up old DOM and reset cleanUpTouch\n\n        if (state.el && state.el !== el && state.cleanUpTouch) {\n          state.cleanUpTouch();\n          addState.cleanUpTouch = undefined;\n        } // only attach if we want to track touch\n\n\n        if (props.trackTouch && el) {\n          addState.cleanUpTouch = attachTouch(el, !props.preventDefaultTouchmoveEvent);\n        } // store event attached DOM el for comparison, clean up, and re-attachment\n\n\n        return _extends({}, state, {\n          el: el\n        }, addState);\n      });\n    }; // set ref callback to attach touch event listeners\n\n\n    var output = {\n      ref: onRef\n    }; // if track mouse attach mouse down listener\n\n    if (handlerProps.trackMouse) {\n      output.onMouseDown = onStart;\n    }\n\n    return [output, attachTouch];\n  }\n\n  function updateTransientState(state, props, attachTouch) {\n    var addState = {}; // clean up touch handlers if no longer tracking touches\n\n    if (!props.trackTouch && state.cleanUpTouch) {\n      state.cleanUpTouch();\n      addState.cleanUpTouch = undefined;\n    } else if (props.trackTouch && !state.cleanUpTouch) {\n      // attach/re-attach touch handlers\n      if (state.el) {\n        addState.cleanUpTouch = attachTouch(state.el, !props.preventDefaultTouchmoveEvent);\n      }\n    }\n\n    return _extends({}, state, addState);\n  }\n\n  function useSwipeable(options) {\n    var trackMouse = options.trackMouse;\n    var transientState = React.useRef(_extends({}, initialState));\n    var transientProps = React.useRef(_extends({}, defaultProps));\n    transientProps.current = _extends({}, defaultProps, options);\n\n    var _React$useMemo = React.useMemo(function () {\n      return getHandlers(function (stateSetter) {\n        return transientState.current = stateSetter(transientState.current, transientProps.current);\n      }, {\n        trackMouse: trackMouse\n      });\n    }, [trackMouse]),\n        handlers = _React$useMemo[0],\n        attachTouch = _React$useMemo[1];\n\n    transientState.current = updateTransientState(transientState.current, transientProps.current, attachTouch);\n    return handlers;\n  }\n\n  exports.DOWN = DOWN;\n  exports.LEFT = LEFT;\n  exports.RIGHT = RIGHT;\n  exports.UP = UP;\n  exports.useSwipeable = useSwipeable;\n});","map":{"version":3,"sources":["../src/types.ts","../src/index.ts"],"names":["LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventDefaultTouchmoveEvent","rotationAngle","trackMouse","trackTouch","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","absX","deltaX","deltaY","angle","angleInRadians","Math","x","pos","y","onStart","event","set","props","document","clientX","clientY","rotateXYByAngle","onMove","state","absY","time","velocity","vxvy","dir","getDirection","eventData","cancelablePageSwipe","onEnd","onSwipedDir","cleanUpMouse","onUp","attachTouch","cleanup","el","tls","e","h","passive","onRef","addState","output","ref","handlerProps","useSwipeable","options","transientState","React","transientProps","handlers","getHandlers","stateSetter","updateTransientState"],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  absX: number;\n  absY: number;\n  deltaX: number;\n  deltaY: number;\n  dir: SwipeDirections;\n  event: HandledEvents;\n  first: boolean;\n  initial: Vector2;\n  velocity: number;\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableCallbacks = {\n  // Event handler/callbacks\n  onSwiped: SwipeCallback;\n  onSwipedDown: SwipeCallback;\n  onSwipedLeft: SwipeCallback;\n  onSwipedRight: SwipeCallback;\n  onSwipedUp: SwipeCallback;\n  onSwiping: SwipeCallback;\n  onTap: TapCallback;\n};\n\n// Configuration Options\nexport interface ConfigurationOptions {\n  delta: number;\n  preventDefaultTouchmoveEvent: boolean;\n  rotationAngle: number;\n  trackMouse: boolean;\n  trackTouch: boolean;\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (el: HTMLElement, passive: boolean) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps = {\n  delta: 10,\n  preventDefaultTouchmoveEvent: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    // if more than a single touch don't track, for now...\n    if (event && \"touches\" in event && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } =\n        \"touches\" in event ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      return {\n        ...state,\n        ...initialState,\n        initial: [...xy],\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (\"touches\" in event && event.touches.length > 1) {\n        return state;\n      }\n      const { clientX, clientY } =\n        \"touches\" in event ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      if (absX < props.delta && absY < props.delta && !state.swiping)\n        return state;\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable(handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (props.onSwiping || props.onSwiped || `onSwiped${dir}` in props) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventDefaultTouchmoveEvent &&\n        props.trackTouch &&\n        event.cancelable\n      )\n        event.preventDefault();\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        eventData = { ...state.eventData, event };\n        props.onSwiped && props.onSwiped(eventData);\n\n        const onSwipedDir = `onSwiped${eventData.dir}`;\n        if (onSwipedDir in props) {\n          ((props as any)[onSwipedDir] as SwipeCallback)(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * Switch of \"passive\" property for now.\n   * When `preventDefaultTouchmoveEvent` is:\n   * - true => { passive: false }\n   * - false => { passive: true }\n   *\n   * Could take entire `addEventListener` options object as a param later?\n   */\n  const attachTouch: AttachTouch = (el, passive) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void\n      ][] = [\n        [touchStart, onStart],\n        [touchMove, onMove],\n        [touchEnd, onEnd],\n      ];\n      tls.forEach(([e, h]) => el.addEventListener(e, h, { passive }));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = undefined;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(\n          el,\n          !props.preventDefaultTouchmoveEvent\n        );\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeableProps,\n  attachTouch: AttachTouch\n) {\n  const addState: { cleanUpTouch?(): void } = {};\n  // clean up touch handlers if no longer tracking touches\n  if (!props.trackTouch && state.cleanUpTouch) {\n    state.cleanUpTouch();\n    addState.cleanUpTouch = undefined;\n  } else if (props.trackTouch && !state.cleanUpTouch) {\n    // attach/re-attach touch handlers\n    if (state.el) {\n      addState.cleanUpTouch = attachTouch(\n        state.el,\n        !props.preventDefaultTouchmoveEvent\n      );\n    }\n  }\n  return { ...state, ...addState };\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n  transientProps.current = { ...defaultProps, ...options };\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n"]},"metadata":{},"sourceType":"script"}