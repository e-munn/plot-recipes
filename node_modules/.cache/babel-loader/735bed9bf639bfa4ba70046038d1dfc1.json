{"ast":null,"code":"import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"sources":["/Users/elimunn/Desktop/plot-recipes/node_modules/mathjs/lib/esm/expression/node/IndexNode.js"],"names":["isBigNumber","isConstantNode","isNode","isRangeNode","isSymbolNode","map","escape","factory","getSafeProperty","name","dependencies","createIndexNode","_ref","Range","Node","size","IndexNode","dimensions","dotNotation","SyntaxError","Array","isArray","every","TypeError","isObjectProperty","Error","prototype","type","isIndexNode","_compile","math","argNames","evalDimensions","range","i","needsEnd","childArgNames","Object","create","end","evalStart","start","evalEnd","evalStep","step","evalDimension","scope","args","context","s","valueOf","childArgs","createRange","_evalStart","_evalEnd","_evalStep","_childArgNames","evalRange","_evalRange","index","evalIndexNode","forEach","callback","length","_ifNode","clone","slice","value","getObjectProperty","_toString","options","join","toJSON","mathjs","fromJSON","json","toHTML","_toTex","toTex","toNumber","isClass"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,cAAtB,EAAsCC,MAAtC,EAA8CC,WAA9C,EAA2DC,YAA3D,QAA+E,mBAA/E;AACA,SAASC,GAAT,QAAoB,sBAApB;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,wBAAxB;AACA,SAASC,eAAT,QAAgC,wBAAhC;AACA,IAAIC,IAAI,GAAG,WAAX;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,MAAV,EAAkB,MAAlB,CAAnB;AACA,OAAO,IAAIC,eAAe,GAAG,eAAeJ,OAAO,CAACE,IAAD,EAAOC,YAAP,EAAsBE,IAAD,IAAU;AAChF,MAAI;AACFC,IAAAA,KADE;AAEFC,IAAAA,IAFE;AAGFC,IAAAA;AAHE,MAIAH,IAJJ;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACE,WAASI,SAAT,CAAmBC,UAAnB,EAA+BC,WAA/B,EAA4C;AAC1C,QAAI,EAAE,gBAAgBF,SAAlB,CAAJ,EAAkC;AAChC,YAAM,IAAIG,WAAJ,CAAgB,kDAAhB,CAAN;AACD;;AAED,SAAKF,UAAL,GAAkBA,UAAlB;AACA,SAAKC,WAAL,GAAmBA,WAAW,IAAI,KAAlC,CAN0C,CAMD;;AAEzC,QAAI,CAACE,KAAK,CAACC,OAAN,CAAcJ,UAAd,CAAD,IAA8B,CAACA,UAAU,CAACK,KAAX,CAAiBpB,MAAjB,CAAnC,EAA6D;AAC3D,YAAM,IAAIqB,SAAJ,CAAc,4DAAd,CAAN;AACD;;AAED,QAAI,KAAKL,WAAL,IAAoB,CAAC,KAAKM,gBAAL,EAAzB,EAAkD;AAChD,YAAM,IAAIC,KAAJ,CAAU,mDAAV,CAAN;AACD;AACF;;AAEDT,EAAAA,SAAS,CAACU,SAAV,GAAsB,IAAIZ,IAAJ,EAAtB;AACAE,EAAAA,SAAS,CAACU,SAAV,CAAoBC,IAApB,GAA2B,WAA3B;AACAX,EAAAA,SAAS,CAACU,SAAV,CAAoBE,WAApB,GAAkC,IAAlC;AACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEEZ,EAAAA,SAAS,CAACU,SAAV,CAAoBG,QAApB,GAA+B,UAAUC,IAAV,EAAgBC,QAAhB,EAA0B;AACvD;AACA;AACA;AACA;AACA;AACA,QAAIC,cAAc,GAAG3B,GAAG,CAAC,KAAKY,UAAN,EAAkB,UAAUgB,KAAV,EAAiBC,CAAjB,EAAoB;AAC5D,UAAI/B,WAAW,CAAC8B,KAAD,CAAf,EAAwB;AACtB,YAAIA,KAAK,CAACE,QAAN,EAAJ,EAAsB;AACpB;AACA,cAAIC,aAAa,GAAGC,MAAM,CAACC,MAAP,CAAcP,QAAd,CAApB;AACAK,UAAAA,aAAa,CAACG,GAAd,GAAoB,IAApB;;AAEA,cAAIC,SAAS,GAAGP,KAAK,CAACQ,KAAN,CAAYZ,QAAZ,CAAqBC,IAArB,EAA2BM,aAA3B,CAAhB;;AAEA,cAAIM,OAAO,GAAGT,KAAK,CAACM,GAAN,CAAUV,QAAV,CAAmBC,IAAnB,EAAyBM,aAAzB,CAAd;;AAEA,cAAIO,QAAQ,GAAGV,KAAK,CAACW,IAAN,GAAaX,KAAK,CAACW,IAAN,CAAWf,QAAX,CAAoBC,IAApB,EAA0BM,aAA1B,CAAb,GAAwD,YAAY;AACjF,mBAAO,CAAP;AACD,WAFD;AAGA,iBAAO,SAASS,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,gBAAIC,CAAC,GAAGlC,IAAI,CAACiC,OAAD,CAAJ,CAAcE,OAAd,EAAR;AACA,gBAAIC,SAAS,GAAGd,MAAM,CAACC,MAAP,CAAcS,IAAd,CAAhB;AACAI,YAAAA,SAAS,CAACZ,GAAV,GAAgBU,CAAC,CAACf,CAAD,CAAjB;AACA,mBAAOkB,WAAW,CAACZ,SAAS,CAACM,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAV,EAAuCN,OAAO,CAACI,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAA9C,EAA2EL,QAAQ,CAACG,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAnF,CAAlB;AACD,WALD;AAMD,SAlBD,MAkBO;AACL;AACA,cAAIK,UAAU,GAAGpB,KAAK,CAACQ,KAAN,CAAYZ,QAAZ,CAAqBC,IAArB,EAA2BC,QAA3B,CAAjB;;AAEA,cAAIuB,QAAQ,GAAGrB,KAAK,CAACM,GAAN,CAAUV,QAAV,CAAmBC,IAAnB,EAAyBC,QAAzB,CAAf;;AAEA,cAAIwB,SAAS,GAAGtB,KAAK,CAACW,IAAN,GAAaX,KAAK,CAACW,IAAN,CAAWf,QAAX,CAAoBC,IAApB,EAA0BC,QAA1B,CAAb,GAAmD,YAAY;AAC7E,mBAAO,CAAP;AACD,WAFD;;AAIA,iBAAO,SAASc,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,mBAAOI,WAAW,CAACC,UAAU,CAACP,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAX,EAAmCM,QAAQ,CAACR,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAA3C,EAAmEO,SAAS,CAACT,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAA5E,CAAlB;AACD,WAFD;AAGD;AACF,OAjCD,MAiCO,IAAI5C,YAAY,CAAC6B,KAAD,CAAZ,IAAuBA,KAAK,CAACxB,IAAN,KAAe,KAA1C,EAAiD;AACtD;AACA,YAAI+C,cAAc,GAAGnB,MAAM,CAACC,MAAP,CAAcP,QAAd,CAArB;;AAEAyB,QAAAA,cAAc,CAACjB,GAAf,GAAqB,IAArB;;AAEA,YAAIkB,SAAS,GAAGxB,KAAK,CAACJ,QAAN,CAAeC,IAAf,EAAqB0B,cAArB,CAAhB;;AAEA,eAAO,SAASX,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,cAAIC,CAAC,GAAGlC,IAAI,CAACiC,OAAD,CAAJ,CAAcE,OAAd,EAAR;AACA,cAAIC,SAAS,GAAGd,MAAM,CAACC,MAAP,CAAcS,IAAd,CAAhB;AACAI,UAAAA,SAAS,CAACZ,GAAV,GAAgBU,CAAC,CAACf,CAAD,CAAjB;AACA,iBAAOuB,SAAS,CAACX,KAAD,EAAQK,SAAR,EAAmBH,OAAnB,CAAhB;AACD,SALD;AAMD,OAdM,MAcA;AACL;AACA,YAAIU,UAAU,GAAGzB,KAAK,CAACJ,QAAN,CAAeC,IAAf,EAAqBC,QAArB,CAAjB;;AAEA,eAAO,SAASc,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,iBAAOU,UAAU,CAACZ,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAAjB;AACD,SAFD;AAGD;AACF,KAxDuB,CAAxB;AAyDA,QAAIW,KAAK,GAAGnD,eAAe,CAACsB,IAAD,EAAO,OAAP,CAA3B;AACA,WAAO,SAAS8B,aAAT,CAAuBd,KAAvB,EAA8BC,IAA9B,EAAoCC,OAApC,EAA6C;AAClD,UAAI/B,UAAU,GAAGZ,GAAG,CAAC2B,cAAD,EAAiB,UAAUa,aAAV,EAAyB;AAC5D,eAAOA,aAAa,CAACC,KAAD,EAAQC,IAAR,EAAcC,OAAd,CAApB;AACD,OAFmB,CAApB;AAGA,aAAOW,KAAK,CAAC,GAAG1C,UAAJ,CAAZ;AACD,KALD;AAMD,GAtED;AAuEA;AACF;AACA;AACA;;;AAGED,EAAAA,SAAS,CAACU,SAAV,CAAoBmC,OAApB,GAA8B,UAAUC,QAAV,EAAoB;AAChD,SAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,UAAL,CAAgB8C,MAApC,EAA4C7B,CAAC,EAA7C,EAAiD;AAC/C4B,MAAAA,QAAQ,CAAC,KAAK7C,UAAL,CAAgBiB,CAAhB,CAAD,EAAqB,gBAAgBA,CAAhB,GAAoB,GAAzC,EAA8C,IAA9C,CAAR;AACD;AACF,GAJD;AAKA;AACF;AACA;AACA;AACA;AACA;;;AAGElB,EAAAA,SAAS,CAACU,SAAV,CAAoBrB,GAApB,GAA0B,UAAUyD,QAAV,EAAoB;AAC5C,QAAI7C,UAAU,GAAG,EAAjB;;AAEA,SAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,UAAL,CAAgB8C,MAApC,EAA4C7B,CAAC,EAA7C,EAAiD;AAC/CjB,MAAAA,UAAU,CAACiB,CAAD,CAAV,GAAgB,KAAK8B,OAAL,CAAaF,QAAQ,CAAC,KAAK7C,UAAL,CAAgBiB,CAAhB,CAAD,EAAqB,gBAAgBA,CAAhB,GAAoB,GAAzC,EAA8C,IAA9C,CAArB,CAAhB;AACD;;AAED,WAAO,IAAIlB,SAAJ,CAAcC,UAAd,EAA0B,KAAKC,WAA/B,CAAP;AACD,GARD;AASA;AACF;AACA;AACA;;;AAGEF,EAAAA,SAAS,CAACU,SAAV,CAAoBuC,KAApB,GAA4B,YAAY;AACtC,WAAO,IAAIjD,SAAJ,CAAc,KAAKC,UAAL,CAAgBiD,KAAhB,CAAsB,CAAtB,CAAd,EAAwC,KAAKhD,WAA7C,CAAP;AACD,GAFD;AAGA;AACF;AACA;AACA;;;AAGEF,EAAAA,SAAS,CAACU,SAAV,CAAoBF,gBAApB,GAAuC,YAAY;AACjD,WAAO,KAAKP,UAAL,CAAgB8C,MAAhB,KAA2B,CAA3B,IAAgC9D,cAAc,CAAC,KAAKgB,UAAL,CAAgB,CAAhB,CAAD,CAA9C,IAAsE,OAAO,KAAKA,UAAL,CAAgB,CAAhB,EAAmBkD,KAA1B,KAAoC,QAAjH;AACD,GAFD;AAGA;AACF;AACA;AACA;AACA;;;AAGEnD,EAAAA,SAAS,CAACU,SAAV,CAAoB0C,iBAApB,GAAwC,YAAY;AAClD,WAAO,KAAK5C,gBAAL,KAA0B,KAAKP,UAAL,CAAgB,CAAhB,EAAmBkD,KAA7C,GAAqD,IAA5D;AACD,GAFD;AAGA;AACF;AACA;AACA;AACA;;;AAGEnD,EAAAA,SAAS,CAACU,SAAV,CAAoB2C,SAApB,GAAgC,UAAUC,OAAV,EAAmB;AACjD;AACA,WAAO,KAAKpD,WAAL,GAAmB,MAAM,KAAKkD,iBAAL,EAAzB,GAAoD,MAAM,KAAKnD,UAAL,CAAgBsD,IAAhB,CAAqB,IAArB,CAAN,GAAmC,GAA9F;AACD,GAHD;AAIA;AACF;AACA;AACA;;;AAGEvD,EAAAA,SAAS,CAACU,SAAV,CAAoB8C,MAApB,GAA6B,YAAY;AACvC,WAAO;AACLC,MAAAA,MAAM,EAAE,WADH;AAELxD,MAAAA,UAAU,EAAE,KAAKA,UAFZ;AAGLC,MAAAA,WAAW,EAAE,KAAKA;AAHb,KAAP;AAKD,GAND;AAOA;AACF;AACA;AACA;AACA;AACA;AACA;;;AAGEF,EAAAA,SAAS,CAAC0D,QAAV,GAAqB,UAAUC,IAAV,EAAgB;AACnC,WAAO,IAAI3D,SAAJ,CAAc2D,IAAI,CAAC1D,UAAnB,EAA+B0D,IAAI,CAACzD,WAApC,CAAP;AACD,GAFD;AAGA;AACF;AACA;AACA;AACA;;;AAGEF,EAAAA,SAAS,CAACU,SAAV,CAAoBkD,MAApB,GAA6B,UAAUN,OAAV,EAAmB;AAC9C;AACA,QAAIrD,UAAU,GAAG,EAAjB;;AAEA,SAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjB,UAAL,CAAgB8C,MAApC,EAA4C7B,CAAC,EAA7C,EAAiD;AAC/CjB,MAAAA,UAAU,CAACiB,CAAD,CAAV,GAAgB,KAAKjB,UAAL,CAAgBiB,CAAhB,EAAmB0C,MAAnB,EAAhB;AACD;;AAED,QAAI,KAAK1D,WAAT,EAAsB;AACpB,aAAO,gEAAgE,0CAAhE,GAA6GZ,MAAM,CAAC,KAAK8D,iBAAL,EAAD,CAAnH,GAAgJ,SAAvJ;AACD,KAFD,MAEO;AACL,aAAO,oEAAoEnD,UAAU,CAACsD,IAAX,CAAgB,uCAAhB,CAApE,GAA+H,iEAAtI;AACD;AACF,GAbD;AAcA;AACF;AACA;AACA;AACA;;;AAGEvD,EAAAA,SAAS,CAACU,SAAV,CAAoBmD,MAApB,GAA6B,UAAUP,OAAV,EAAmB;AAC9C,QAAIrD,UAAU,GAAG,KAAKA,UAAL,CAAgBZ,GAAhB,CAAoB,UAAU4B,KAAV,EAAiB;AACpD,aAAOA,KAAK,CAAC6C,KAAN,CAAYR,OAAZ,CAAP;AACD,KAFgB,CAAjB;AAGA,WAAO,KAAKpD,WAAL,GAAmB,MAAM,KAAKkD,iBAAL,EAAN,GAAiC,EAApD,GAAyD,OAAOnD,UAAU,CAACsD,IAAX,CAAgB,GAAhB,CAAP,GAA8B,GAA9F;AACD,GALD,CAvPgF,CA4P7E;;;AAGH,WAASnB,WAAT,CAAqBX,KAArB,EAA4BF,GAA5B,EAAiCK,IAAjC,EAAuC;AACrC,WAAO,IAAI/B,KAAJ,CAAUb,WAAW,CAACyC,KAAD,CAAX,GAAqBA,KAAK,CAACsC,QAAN,EAArB,GAAwCtC,KAAlD,EAAyDzC,WAAW,CAACuC,GAAD,CAAX,GAAmBA,GAAG,CAACwC,QAAJ,EAAnB,GAAoCxC,GAA7F,EAAkGvC,WAAW,CAAC4C,IAAD,CAAX,GAAoBA,IAAI,CAACmC,QAAL,EAApB,GAAsCnC,IAAxI,CAAP;AACD;;AAED,SAAO5B,SAAP;AACD,CApQkD,EAoQhD;AACDgE,EAAAA,OAAO,EAAE,IADR;AAED9E,EAAAA,MAAM,EAAE;AAFP,CApQgD,CAA5C","sourcesContent":["import { isBigNumber, isConstantNode, isNode, isRangeNode, isSymbolNode } from '../../utils/is.js';\nimport { map } from '../../utils/array.js';\nimport { escape } from '../../utils/string.js';\nimport { factory } from '../../utils/factory.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nvar name = 'IndexNode';\nvar dependencies = ['Range', 'Node', 'size'];\nexport var createIndexNode = /* #__PURE__ */factory(name, dependencies, (_ref) => {\n  var {\n    Range,\n    Node,\n    size\n  } = _ref;\n\n  /**\n   * @constructor IndexNode\n   * @extends Node\n   *\n   * Describes a subset of a matrix or an object property.\n   * Cannot be used on its own, needs to be used within an AccessorNode or\n   * AssignmentNode.\n   *\n   * @param {Node[]} dimensions\n   * @param {boolean} [dotNotation=false]  Optional property describing whether\n   *                                       this index was written using dot\n   *                                       notation like `a.b`, or using bracket\n   *                                       notation like `a[\"b\"]` (default).\n   *                                       Used to stringify an IndexNode.\n   */\n  function IndexNode(dimensions, dotNotation) {\n    if (!(this instanceof IndexNode)) {\n      throw new SyntaxError('Constructor must be called with the new operator');\n    }\n\n    this.dimensions = dimensions;\n    this.dotNotation = dotNotation || false; // validate input\n\n    if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {\n      throw new TypeError('Array containing Nodes expected for parameter \"dimensions\"');\n    }\n\n    if (this.dotNotation && !this.isObjectProperty()) {\n      throw new Error('dotNotation only applicable for object properties');\n    }\n  }\n\n  IndexNode.prototype = new Node();\n  IndexNode.prototype.type = 'IndexNode';\n  IndexNode.prototype.isIndexNode = true;\n  /**\n   * Compile a node into a JavaScript function.\n   * This basically pre-calculates as much as possible and only leaves open\n   * calculations which depend on a dynamic scope with variables.\n   * @param {Object} math     Math.js namespace with functions and constants.\n   * @param {Object} argNames An object with argument names as key and `true`\n   *                          as value. Used in the SymbolNode to optimize\n   *                          for arguments from user assigned functions\n   *                          (see FunctionAssignmentNode) or special symbols\n   *                          like `end` (see IndexNode).\n   * @return {function} Returns a function which can be called like:\n   *                        evalNode(scope: Object, args: Object, context: *)\n   */\n\n  IndexNode.prototype._compile = function (math, argNames) {\n    // TODO: implement support for bignumber (currently bignumbers are silently\n    //       reduced to numbers when changing the value to zero-based)\n    // TODO: Optimization: when the range values are ConstantNodes,\n    //       we can beforehand resolve the zero-based value\n    // optimization for a simple object property\n    var evalDimensions = map(this.dimensions, function (range, i) {\n      if (isRangeNode(range)) {\n        if (range.needsEnd()) {\n          // create a range containing end (like '4:end')\n          var childArgNames = Object.create(argNames);\n          childArgNames.end = true;\n\n          var evalStart = range.start._compile(math, childArgNames);\n\n          var evalEnd = range.end._compile(math, childArgNames);\n\n          var evalStep = range.step ? range.step._compile(math, childArgNames) : function () {\n            return 1;\n          };\n          return function evalDimension(scope, args, context) {\n            var s = size(context).valueOf();\n            var childArgs = Object.create(args);\n            childArgs.end = s[i];\n            return createRange(evalStart(scope, childArgs, context), evalEnd(scope, childArgs, context), evalStep(scope, childArgs, context));\n          };\n        } else {\n          // create range\n          var _evalStart = range.start._compile(math, argNames);\n\n          var _evalEnd = range.end._compile(math, argNames);\n\n          var _evalStep = range.step ? range.step._compile(math, argNames) : function () {\n            return 1;\n          };\n\n          return function evalDimension(scope, args, context) {\n            return createRange(_evalStart(scope, args, context), _evalEnd(scope, args, context), _evalStep(scope, args, context));\n          };\n        }\n      } else if (isSymbolNode(range) && range.name === 'end') {\n        // SymbolNode 'end'\n        var _childArgNames = Object.create(argNames);\n\n        _childArgNames.end = true;\n\n        var evalRange = range._compile(math, _childArgNames);\n\n        return function evalDimension(scope, args, context) {\n          var s = size(context).valueOf();\n          var childArgs = Object.create(args);\n          childArgs.end = s[i];\n          return evalRange(scope, childArgs, context);\n        };\n      } else {\n        // ConstantNode\n        var _evalRange = range._compile(math, argNames);\n\n        return function evalDimension(scope, args, context) {\n          return _evalRange(scope, args, context);\n        };\n      }\n    });\n    var index = getSafeProperty(math, 'index');\n    return function evalIndexNode(scope, args, context) {\n      var dimensions = map(evalDimensions, function (evalDimension) {\n        return evalDimension(scope, args, context);\n      });\n      return index(...dimensions);\n    };\n  };\n  /**\n   * Execute a callback for each of the child nodes of this node\n   * @param {function(child: Node, path: string, parent: Node)} callback\n   */\n\n\n  IndexNode.prototype.forEach = function (callback) {\n    for (var i = 0; i < this.dimensions.length; i++) {\n      callback(this.dimensions[i], 'dimensions[' + i + ']', this);\n    }\n  };\n  /**\n   * Create a new IndexNode having it's childs be the results of calling\n   * the provided callback function for each of the childs of the original node.\n   * @param {function(child: Node, path: string, parent: Node): Node} callback\n   * @returns {IndexNode} Returns a transformed copy of the node\n   */\n\n\n  IndexNode.prototype.map = function (callback) {\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this._ifNode(callback(this.dimensions[i], 'dimensions[' + i + ']', this));\n    }\n\n    return new IndexNode(dimensions, this.dotNotation);\n  };\n  /**\n   * Create a clone of this node, a shallow copy\n   * @return {IndexNode}\n   */\n\n\n  IndexNode.prototype.clone = function () {\n    return new IndexNode(this.dimensions.slice(0), this.dotNotation);\n  };\n  /**\n   * Test whether this IndexNode contains a single property name\n   * @return {boolean}\n   */\n\n\n  IndexNode.prototype.isObjectProperty = function () {\n    return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === 'string';\n  };\n  /**\n   * Returns the property name if IndexNode contains a property.\n   * If not, returns null.\n   * @return {string | null}\n   */\n\n\n  IndexNode.prototype.getObjectProperty = function () {\n    return this.isObjectProperty() ? this.dimensions[0].value : null;\n  };\n  /**\n   * Get string representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toString = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    return this.dotNotation ? '.' + this.getObjectProperty() : '[' + this.dimensions.join(', ') + ']';\n  };\n  /**\n   * Get a JSON representation of the node\n   * @returns {Object}\n   */\n\n\n  IndexNode.prototype.toJSON = function () {\n    return {\n      mathjs: 'IndexNode',\n      dimensions: this.dimensions,\n      dotNotation: this.dotNotation\n    };\n  };\n  /**\n   * Instantiate an IndexNode from its JSON representation\n   * @param {Object} json  An object structured like\n   *                       `{\"mathjs\": \"IndexNode\", dimensions: [...], dotNotation: false}`,\n   *                       where mathjs is optional\n   * @returns {IndexNode}\n   */\n\n\n  IndexNode.fromJSON = function (json) {\n    return new IndexNode(json.dimensions, json.dotNotation);\n  };\n  /**\n   * Get HTML representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype.toHTML = function (options) {\n    // format the parameters like \"[1, 0:5]\"\n    var dimensions = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      dimensions[i] = this.dimensions[i].toHTML();\n    }\n\n    if (this.dotNotation) {\n      return '<span class=\"math-operator math-accessor-operator\">.</span>' + '<span class=\"math-symbol math-property\">' + escape(this.getObjectProperty()) + '</span>';\n    } else {\n      return '<span class=\"math-parenthesis math-square-parenthesis\">[</span>' + dimensions.join('<span class=\"math-separator\">,</span>') + '<span class=\"math-parenthesis math-square-parenthesis\">]</span>';\n    }\n  };\n  /**\n   * Get LaTeX representation\n   * @param {Object} options\n   * @return {string} str\n   */\n\n\n  IndexNode.prototype._toTex = function (options) {\n    var dimensions = this.dimensions.map(function (range) {\n      return range.toTex(options);\n    });\n    return this.dotNotation ? '.' + this.getObjectProperty() + '' : '_{' + dimensions.join(',') + '}';\n  }; // helper function to create a Range from start, step and end\n\n\n  function createRange(start, end, step) {\n    return new Range(isBigNumber(start) ? start.toNumber() : start, isBigNumber(end) ? end.toNumber() : end, isBigNumber(step) ? step.toNumber() : step);\n  }\n\n  return IndexNode;\n}, {\n  isClass: true,\n  isNode: true\n});"]},"metadata":{},"sourceType":"module"}